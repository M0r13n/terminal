#!/usr/bin/env python3

import json
import os

import click
from flask.cli import FlaskGroup
from sqlalchemy.exc import IntegrityError, InvalidRequestError

from executor.run_cmd import CommandExecutor
from server.app import create_app
from server.logging import setup_logger

app = create_app()
cli = FlaskGroup(create_app=create_app)

HERE = os.path.abspath(os.path.dirname(__file__))
PROJECT_ROOT = os.path.join(HERE, "project")


@cli.command()
def create_db():
    """ Drops all existing tables and creates them afterwards """
    db.create_all()
    print("Created")


@cli.command()
def drop_db():
    """Drops the db tables."""
    db.drop_all()
    print("Dropped")


@cli.command()
def clean_db():
    """ Drop existing tables and create fresh new ones """
    db.drop_all()
    db.create_all()
    print("Created")


@cli.command()
def load_badges():
    """Creates and saves badges as defined in data.json"""
    with open("data/badges.json", "r") as badge_fd:
        badge_dict: dict = json.loads(badge_fd.read())
        for _, badge in badge_dict.items():
            try:
                Badge.create(
                    name=badge['name'],
                    src_filename=badge['src_filename'],
                    description=badge['description'],
                    condition=badge.get('condition')
                )
            except (IntegrityError, InvalidRequestError):
                print(f"Skipping {badge['name']} because it already exists.")
    print(f"Created badges. Now there are {Badge.query.count()} badges.")


@cli.command()
def load_challenges():
    """Load all challenges from file"""
    with open("executor/docker_image/ro_volume/challenges.json", "r") as badge_fd:
        challenge_dict: dict = json.loads(badge_fd.read())
        for _, challenge in challenge_dict.items():
            try:
                Challenge.create(
                    identifier=challenge['identifier'],
                    name=challenge['name'],
                    description=challenge['description'],
                    help=challenge.get('help', None),
                    external_link=challenge.get('external_link', None),
                )
            except (IntegrityError, InvalidRequestError):
                print(f"Skipping {challenge['name']} because it already exists.")
    print(f"Created Challenges. Now there are {Challenge.query.count()} challenges.")


@cli.command()
def test():
    """ Test docker """
    c = CommandExecutor()
    output = c.run_command_parsed(("echo hi",), challenge="01_list_all_files")
    print(output)


from server.models import *
import pprint


def for_each_group(func_to_call, query=None, *args, **kwargs):
    if query is None:
        query = User.query
    total = func_to_call(query, *args, **kwargs)
    cg = func_to_call(query.filter(User.mode == GameModes.ControlGroup), *args, **kwargs)
    bg = func_to_call(query.filter(User.mode == GameModes.BADGE), *args, **kwargs)
    pb = func_to_call(query.filter(User.mode == GameModes.PROGRESSBAR), *args, **kwargs)
    return {
        'ALL': total,
        'CG': cg,
        'BG': bg,
        'PB': pb
    }


@cli.command()
def total_time():
    """ Get the total time spent for each group for each group"""
    pp = pprint.PrettyPrinter(indent=4)
    threshold = 1800

    def users_total_time(query, threshold=threshold):
        # average time spent on solving the challenge per user
        for user in query.all():
            commands = SubmittedCommand.query.filter(
                SubmittedCommand.user_uuid == user.uuid
            ).order_by(
                SubmittedCommand.time_submitted.asc()
            ).all()

            total_time = 0
            for i, command in enumerate(commands):
                try:
                    next_c = commands[i + 1]
                except IndexError:
                    continue
                span = (next_c.time_submitted - command.time_submitted).seconds
                if span < threshold:
                    total_time += span
            return total_time

    pp.pprint(for_each_group(users_total_time, threshold))


@cli.command()
@click.argument("correct",
                required=False,
                type=click.Choice(['correct', 'wrong']))
def total_submissions(correct):
    """ Total submissions for each group. Provide correct or wrong as argument to filter."""
    pp = pprint.PrettyPrinter(indent=4)

    def tot_subs(query):
        if not correct:
            return sum([len(user.commands) for user in query.all()])
        elif correct == 'correct':
            return sum([SubmittedCommand.query.filter(SubmittedCommand.user_uuid == user.uuid, SubmittedCommand.solved_challenge == True).count() for user in query.all()])
        elif correct == 'wrong':
            return sum([SubmittedCommand.query.filter(SubmittedCommand.user_uuid == user.uuid, SubmittedCommand.solved_challenge == False).count() for user in query.all()])

    pp.pprint(for_each_group(tot_subs))


if __name__ == "__main__":
    # Logging
    setup_logger(level=logging.DEBUG if app.config['DEBUG'] else logging.INFO)
    cli()
